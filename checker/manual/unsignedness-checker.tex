\htmlhr
\chapter{Unsignedness Checker\label{unsignedness-checker}}

The Unsignedness Checker guarantees that signed and unsigned values are not mixed 
together in a computation. In addition, it prohibits meaningless operations, such 
as division on an unsigned value.

\section{Annotations\label{unsignedness-checker-annotations}}

The Unsignedness Checker uses type annotations to indicate the signedness that the programmer intends an expression to have.

These are the qualifiers in the Unsignedness type system:

\begin{description}

\item[\refqualclass{checker/unsignedness/qual}{Unsigned}]
    indicates that the programmer intends the annotated value to be interpreted as unsigned.

\item[\refqualclass{checker/unsignedness/qual}{Signed}]
    indicates that the programmer intends the annotated value to be interpreted
    as signed. This is how Java interprets all values of relevant type, and as
    such is default for such types in this checker.

\item[\refqualclass{checker/unsignedness/qual}{Constant}]
    indicates that a value is a compile-time constant and could justifiably be
    interpreted as unsigned or signed. This is used internally, and should not 
    be written by the programmer.

\item[\refqualclass{checker/unsignedness/qual}{UnknownSignedness}]
    indicates that a value's type is not relevant or known to this checker. 
    This annotation is used internally, and should not be
    written by the programmer.

\end{description}

\begin{figure}
\includeimage{unsignedness}{3.5cm}
\caption{A partial diagram of the subtyping hierarchy of the qualifiers in the 
Unsignedness type system.}
\label{fig-unsignedness-hierarchy}
\end{figure}

\subsection{Default Qualifiers\label{unsignedness-checker-annotations-default-qualifiers}}

The only type qualifier in this system that the programmer should ever write is
\code{@Unsigned}. When a programmer leaves an expression unannotated, the
Unsignedness Checker handles it in one of the following ways:

\begin{itemize}

    \item
    All \code{byte}, \code{short}, \code{int}, and \code{long} literals default
    to \code{@constant}.
    \item
    All \code{byte}, \code{short}, \code{int}, and \code{long} variables default
    to \code{@Signed}.
    \item
    All other expressions default to \code{@UnknownSignedness}.

\end{itemize}

\section{Prohibited Operations\label{unsignedness-checker-Prohibited-Operations}}

The Unsignedness Checker prohibits the following uses of operators:

\begin{itemize}

    \item   
    Division ( \code{/} ) or modulus ( \code{\%} ) with an \code{@Unsigned}
    operand.
    \item   
    Signed right shift ( \verb{>>} ) with an \code{@Unsigned} left operand.
    \item   
    Unsigned right shift ( \verb{>>>} ) with a \code{@Signed} left operand.
    \item   
    Any other binary operator with one \code{@Unsigned} operand and one
    \code{@Signed} operand.

\end{itemize}

There are also occasions when comparisons can be rendered illegitimate for
unsigned interpretations. For this reason, the Unsignedness Checker will prohibit the following uses of comparators:

\begin{itemize}

    \item   
    Greater/less than (or equal) comparators
    ( \code{<}, \code{<=}, \code{>}, \code{>=} ) with an \code{@Unsigned}
    operand.
    \item   
    Equals ( \code{==} ) and not equals ( \code{!=} ) with one \code{@Unsigned}
    operand and one \code{Signed} operand.

\end{itemize}

The Unsignedness Checker also ensures that assignments and pseudo assignments are
correct. For example, it is unsound to assign a \code{@Signed} expression to an
\code{@Unsigned} variable.

\section{Rationale\label{unsignedness-checker-rationale}}

The intent of the Unsignedness Checker is to prevent the misuse of unsigned
values in Java code. All relevant Java operations interpret operands as signed,
rendering some operations unsound for unsigned values. A program should not use
unsigned values with such operations, because the operation would interpret a
large unsigned integer as negative, producing an undesired outcome.

Consider the following Java code:

\begin{Verbatim}
    int s1 = -1;
    int s2 = -2;

    @Unsigned int u1 = 0xFFFFFFFF;  \\unsigned: 2^32 - 1, signed: -1
    @Unsigned int u2 = 0xFFFFFFFE;  \\unsigned: 2^32 - 2, signed: -2

    int result;

    result = s2 / s1;   \\OK: -2 / -1 is 2
    result = u2 / u1;   \\ERROR: (2^32 - 1) / (2^32 - 2) should not be 2

    s1 = 0;
    s2 = 5;

    u1 = 0xFFFFFFFF;    \\unsigned: 2^32 - 1, signed: -1
    u2 = 5;

    result = s1 % s2;   \\OK: 0 % 5 is 0
    result = u1 % u2;   \\ERROR: (2^32 - 1) % 5 should not be 4
\end{Verbatim}

These examples illustrate why any division or modulus with an unsigned operand 
is illegal. Many other uses of operators are prohibited for similar reasons.